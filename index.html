<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hydrun</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-extra-markers/dist/css/leaflet.extra-markers.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* --- CSS STYLES START --- */
        body {
            font-family: "Segoe UI", sans-serif;
            background: #f2f2f2;
            margin: 0;
            padding: 20px;
            color: #333;
            line-height: 1.6;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            color: #0077ff;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        h2 {
            color: #333;
            font-size: 1.8em;
            margin-top: 0;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        h3 {
            color: #555;
            font-size: 1.4em;
            margin-top: 25px;
            margin-bottom: 10px;
        }

        h4 {
            color: #666;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .card {
            background: white;
            padding: 20px;
            margin-bottom: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
            border: 1px solid #e0e0e0;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #555;
        }

        input[type="text"],
        input[type="number"],
        input[type="email"],
        input[type="time"] { /* Added time input type */
            width: calc(100% - 22px); /* Account for padding and border */
            padding: 11px;
            margin: 8px 0 15px 0;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="email"]:focus,
        input[type="time"]:focus { /* Added time input type */
            border-color: #0077ff;
            outline: none;
        }

        button {
            padding: 12px 20px;
            background: #0077ff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.3s ease;
            width: 100%; /* Full width for consistency */
            margin-top: 10px; /* Space above buttons */
        }

        button:hover {
            background: #0055cc;
        }

        button:active {
            background: #0044bb;
        }

        /* Style for the map container */
        #map {
            width: 100%;
            height: 350px;
            margin-top: 20px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .hidden {
            display: none;
        }

        p {
            margin-top: 15px;
            font-size: 1.1em;
            color: #444;
        }

        ul, ol {
            list-style-type: none; /* Remove default list bullets */
            padding: 0;
            margin: 15px 0;
        }

        ul li, ol li {
            background: #f9f9f9;
            padding: 10px 15px;
            margin-bottom: 8px;
            border-radius: 6px;
            border: 1px solid #eee;
            display: flex;
            justify-content: space-between; /* Space out content if needed */
            align-items: center;
        }

        ol li {
            counter-increment: leaderboard-counter;
            padding-left: 40px; /* Space for counter */
            position: relative;
        }

        ol li::before {
            content: counter(leaderboard-counter) ".";
            position: absolute;
            left: 15px;
            font-weight: bold;
            color: #0077ff;
        }

        .highlight-user {
            background: #e6f2ff; /* Light blue background for current user */
            border-color: #0077ff;
            font-weight: bold;
        }

        /* Moved logout button styling to a class, as it's no longer inside #userDisplay */
        .logout-button {
            display: inline-block;
            width: auto;
            margin-left: 0; /* Adjust margin for its new location */
            padding: 8px 15px;
            background: #dc3545; /* Red for logout */
        }

        .logout-button:hover {
            background: #c82333;
        }

        /* Message for user feedback */
        .feedback-message {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        .feedback-message.show {
            opacity: 1;
        }
        .feedback-message.error {
            background-color: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
        }

        /* Camera specific styles */
        #cameraStream {
            width: 100%;
            height: auto;
            background-color: #000;
            border-radius: 8px;
            display: block; /* Ensure it takes full width */
            margin-bottom: 15px;
        }
        #captureCanvas {
            display: block; /* Hidden by default, shown after capture */
            margin-top: 15px;
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .camera-controls button {
            margin-top: 10px;
        }

        /* New styles for section toggling */
        .tab-buttons {
            display: flex;
            justify-content: center;
            gap: 10px; /* Space between buttons */
            margin-bottom: 25px;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
        }
        .tab-buttons button {
            flex: 1; /* Make buttons take equal width */
            min-width: 120px; /* Ensure buttons don't get too small */
            margin-top: 0; /* Override default button margin */
        }
        .tab-buttons button.active {
            background: #0055cc; /* Darker blue for active tab */
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.2); /* Inset shadow for active state */
        }

        /* Styles for AI Advice sections */
        .ai-advice {
            background-color: #e8f5e9; /* Light green background */
            border: 1px solid #c8e6c9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            color: #2e7d32; /* Dark green text */
        }
        .ai-advice h4 {
            color: #1b5e20; /* Even darker green for heading */
            margin-top: 0;
            margin-bottom: 10px;
        }
        .ai-advice ul {
            list-style-type: disc; /* Use regular bullets for lists */
            margin-left: 20px;
            padding-left: 0;
        }
        .ai-advice ul li {
            background: none;
            border: none;
            padding: 5px 0;
            margin-bottom: 5px;
            color: #388e3c;
        }

        /* Premium Pass Styles */
        .premium-section {
            background-color: #fff3e0; /* Light orange background */
            border: 1px solid #ffe0b2;
            color: #e65100; /* Darker orange text */
        }
        .premium-section h2 {
            color: #ff6f00; /* Orange heading */
            border-bottom-color: #ffcc80;
        }
        .premium-section h3 {
            color: #e65100;
        }
        .premium-content {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px dashed #ffcc80;
        }
        .premium-content ul {
            list-style-type: circle; /* Different bullet for premium lists */
            margin-left: 20px;
            padding-left: 0;
        }
        .premium-content ul li {
            background: none;
            border: none;
            padding: 5px 0;
            margin-bottom: 5px;
            color: #e65100;
        }
        .premium-content p {
            color: #e65100;
            font-style: italic;
        }

        /* Profile Section specific styles */
        #profileSection p {
            margin-bottom: 10px;
        }
        #profileSection .form-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #eee;
            flex-wrap: wrap; /* Allow wrapping for input fields */
        }
        #profileSection .form-group label {
            margin-bottom: 0;
            font-weight: normal;
            flex-grow: 1; /* Allow label to take available space */
            margin-right: 10px;
        }
        #profileSection .form-group input[type="number"],
        #profileSection .form-group input[type="time"] {
            width: auto; /* Allow input to size naturally */
            min-width: 80px; /* Ensure it's not too small */
            margin: 0; /* Remove default input margins */
            flex-shrink: 0; /* Don't shrink the input */
        }

        /* Timer input group */
        .timer-input-group {
            display: flex;
            gap: 5px; /* Space between inputs */
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap; /* Allow wrapping */
        }
        .timer-input-group input {
            width: 60px; /* Smaller width for h, m, s inputs */
            text-align: center;
            padding: 8px; /* Slightly less padding */
            margin: 0; /* Remove default margins */
        }
        .timer-input-group label {
            font-weight: normal;
            margin-right: 5px; /* Space before input */
            margin-bottom: 0; /* Override default label margin */
        }
        .timer-label {
            width: 30px; /* Fixed width for 'h', 'm', 's' labels */
            text-align: right;
            margin-right: 5px;
        }

        /* Moved old switch styles here but they are no longer used by the timers */
        #profileSection .switch {
            position: relative;
            display: inline-block;
            width: 45px;
            height: 25px;
            flex-shrink: 0;
        }

        #profileSection .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        #profileSection .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 25px; /* Rounded slider */
        }

        #profileSection .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 3.5px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%; /* Rounded handle */
        }

        #profileSection input:checked + .slider {
            background-color: #0077ff;
        }

        #profileSection input:focus + .slider {
            box-shadow: 0 0 1px #0077ff;
        }

        #profileSection input:checked + .slider:before {
            -webkit-transform: translateX(20px);
            -ms-transform: translateX(20px);
            transform: translateX(20px);
        }
        /* --- CSS STYLES END --- */
    </style>
</head>
<body>
    <div id="loginContainer" class="card">
        <h2>Login to Hydrun</h2>
        <input type="email" id="userEmail" placeholder="Enter your email" />
        <input type="text" id="usernameInput" placeholder="Choose a username" />
        <button onclick="login()">Login</button>
    </div>

    <div id="appContainer" class="hidden">
        <header>
            <h1>üèÉüíß Hydrun</h1>
            <p>Welcome, <span id="userDisplay"></span>!</p>
        </header>

        <div class="tab-buttons">
            <button id="showWaterBtn" onclick="showSection('waterSection')">üíß Water Tracker</button>
            <button id="showRunBtn" onclick="showSection('runSection')">üèÉ Run Tracker</button>
            <button id="showProfileBtn" onclick="showSection('profileSection')">üë§ Profile</button>
            <button id="showPremiumBtn" onclick="showSection('premiumSection')">‚ú® Premium Pass</button>
        </div>

        <section id="waterSection" class="card">
            <h2>üíß Water Tracker</h2>
            <label>Daily Goal (L): <input type="number" id="waterDailyGoal" value="2" min="0.1" step="0.1" /></label>
            <label>Monthly Goal (L): <input type="number" id="waterMonthlyGoal" value="60" min="1" step="1" /></label>
            <label>Add Water (L): <input type="number" id="waterInput" min="0.1" step="0.1" /></label>
            <button onclick="logWater()">Add Water</button>
            <p>Daily: <span id="waterDailyStatus">Drank: 0.00 L (0.0%)</span></p>
            <p>Monthly: <span id="waterMonthlyStatus">Drank: 0.00 L (0.0%)</span></p>
            <div id="waterFeedback" class="feedback-message hidden"></div>

            <hr>
            <h3>üì∏ Camera for Water Estimation</h3>
            <p>Use your camera to capture an image of your water container. Based on the picture, **you'll need to manually estimate** the water added or remaining and log it above.</p>
            <button onclick="startCamera()">Start Camera</button>
            <button onclick="captureImage()">Capture Image</button>
            <button onclick="stopCamera()">Stop Camera</button>
            <video id="cameraStream" autoplay playsinline class="hidden"></video>
            <canvas id="captureCanvas" class="hidden"></canvas>
            <div id="cameraFeedback" class="feedback-message hidden"></div>

            <hr>
            <div class="ai-advice">
                <h4>üß† AI Water Advice</h4>
                <ul id="waterAdviceList"></ul>
            </div>
        </section>

        <section id="runSection" class="card hidden">
            <h2>üìç Run Tracker</h2>
            <label>Daily Goal (km): <input type="number" id="runDailyGoal" value="5" min="0.1" step="0.1" /></label>
            <label>Monthly Goal (km): <input type="number" id="runMonthlyGoal" value="100" min="1" step="1" /></label>
            <button onclick="startRun()">Start Run</button>
            <button onclick="stopRun()">Stop Run</button>
            <button onclick="markMyLocation()">Mark My Location</button>
            <p id="runStatus">Not running</p>
            <p id="distanceDisplay">Current Run: 0.00 km</p>
            <p>Daily: <span id="runDailyStatus">Ran: 0.00 km (0.0%)</span></p>
            <p>Monthly: <span id="runMonthlyStatus">Ran: 0.00 L (0.0%)</span></p>
            <p>Total Lifetime Run: <span id="totalRunDisplay">0.00 km</span></p>
            <div id="map"></div>
            <div id="runFeedback" class="feedback-message hidden"></div>

            <hr>
            <div class="ai-advice">
                <h4>üß† AI Running Advice</h4>
                <ul id="runAdviceList"></ul>
            </div>

            <hr>
            <h3>üë´ Friends & Leaderboard</h3>
            <label>Add friend by username: <input type="text" id="friendName" placeholder="Friend's username" /></label>
            <button onclick="addFriend()">Add Friend</button>
            <div id="friendFeedback" class="feedback-message hidden"></div>

            <h4>Your Friends</h4>
            <ul id="friendList"></ul>

            <h4>üèÜ Leaderboard</h4>
            <ol id="leaderboardList"></ol>
        </section>

        <section id="profileSection" class="card hidden">
            <h2>üë§ Your Profile</h2>
            <p>Username: <strong id="profileUsernameDisplay"></strong></p>
            <p>Email: <strong id="profileEmailDisplay"></strong></p>

            <hr>

            <h3>üèÉ One-Time Running Timer</h3>
            <p>Set a custom timer for your next jog!</p>
            <div class="timer-input-group">
                <label for="runTimerHours">h</label>
                <input type="number" id="runTimerHours" value="0" min="0" max="23">
                <label for="runTimerMinutes">m</label>
                <input type="number" id="runTimerMinutes" value="0" min="0" max="59">
                <label for="runTimerSeconds">s</label>
                <input type="number" id="runTimerSeconds" value="0" min="0" max="59">
            </div>
            <label for="runTimerMessage">Reminder Message:</label>
            <input type="text" id="runTimerMessage" placeholder="e.g., 'Time to run!' or 'Let's go for a jog!'" value="Time to run!">
            <button onclick="setOneTimeRunTimerReminder()">Set Run Timer</button>
            <p id="runTimerStatus" style="font-weight: bold; margin-top: 10px;">No run timer active.</p>
            <button onclick="cancelOneTimeRunTimerReminder()" style="background-color: #ff9800;">Cancel Run Timer</button>
            <div id="runTimerFeedback" class="feedback-message hidden"></div>

            <hr>

            <h3>üíß One-Time Water Timer</h3>
            <p>Set a custom timer to remind yourself to drink water!</p>
            <div class="timer-input-group">
                <label for="waterTimerHours">h</label>
                <input type="number" id="waterTimerHours" value="0" min="0" max="23">
                <label for="waterTimerMinutes">m</label>
                <input type="number" id="waterTimerMinutes" value="0" min="0" max="59">
                <label for="waterTimerSeconds">s</label>
                <input type="number" id="waterTimerSeconds" value="0" min="0" max="59">
            </div>
            <label for="waterTimerMessage">Reminder Message:</label>
            <input type="text" id="waterTimerMessage" placeholder="e.g., 'Don't forget to drink water!'" value="Don't forget to drink water!">
            <button onclick="setOneTimeWaterTimerReminder()">Set Water Timer</button>
            <p id="waterTimerStatus" style="font-weight: bold; margin-top: 10px;">No water timer active.</p>
            <button onclick="cancelOneTimeWaterTimerReminder()" style="background-color: #ff9800;">Cancel Water Timer</button>
            <div id="waterTimerFeedback" class="feedback-message hidden"></div>

            <hr>

            <button onclick="logout()" class="logout-button">Logout</button>
        </section>


        <section id="premiumSection" class="card premium-section hidden">
            <h2>‚ú® Hydrun Premium Pass</h2>
            <div id="premiumContent">
                <p>Unlock advanced features for just <strong style="color: #ff6f00;">$10/month</strong>!</p>
                <button onclick="activatePremium()">Get Premium Pass!</button>
                <div id="premiumFeedback" class="feedback-message hidden"></div>
            </div>

            <div id="premiumFeatures" class="premium-content hidden">
                <h3>Personalized Training Routine</h3>
                <ul>
                    <li>**Best Running Times:**
                        <ul>
                            <li>For **endurance and fat burning**, consider early morning runs (6 AM - 8 AM) before breakfast to tap into fat reserves.</li>
                            <li>For **performance and speed**, late afternoon (4 PM - 6 PM) often aligns with peak body temperature and muscle efficiency.</li>
                            <li>**Listen to your body** and consider your sleep cycle. Consistency is key!</li>
                        </ul>
                    </li>
                    <li>**Suggested Running Routes:**
                        <ul>
                            <li>**Interval Training (2-3 km loop):** Find a flat path or track. Alternate 1 min fast sprint, 2 min brisk walk/jog for 20-30 mins.</li>
                            <li>**Long Slow Distance (5-10 km loop):** Choose a scenic route with varied terrain. Maintain a conversational pace, focusing on consistent breathing.</li>
                            <li>**Hill Repeats (0.5-1 km incline):** Find a moderate hill. Sprint up (or strong jog), walk down to recover. Repeat 5-8 times.</li>
                            <li>**Explore new areas** using your map! Look for parks, riverside paths, or quiet residential streets.</li>
                        </ul>
                    </li>
                </ul>

                <h3>Make Drinking Water Less Boring</h3>
                <ul>
                    <li>**Infused Water:** Add slices of fresh fruit (lemon, lime, orange, berries), cucumber, mint leaves, or ginger to your water. Let it steep for a few hours in the fridge.</li>
                    <li>**Sparkling Water Mixer:** Mix plain sparkling water with a splash of fruit juice, a few berries, or a slice of citrus for a bubbly treat without excess sugar.</li>
                    <li>**Herbal Tea (Iced or Hot):** Brew your favorite caffeine-free herbal teas (peppermint, chamomile, hibiscus) and enjoy them chilled or warm. They count towards hydration!</li>
                    <li>**Water Challenge:** Set hourly alarms or use an app to remind you to drink. Challenge yourself to finish a certain amount by midday.</li>
                    <li>**Flavor Droplets:** Natural flavor drops (available online or in health stores) can add a hint of taste without calories or artificial sweeteners.</li>
                </ul>
            </div>
        </section>

    </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-extra-markers/dist/js/leaflet.extra-markers.min.js"></script>
    <script>
        /* --- JAVASCRIPT LOGIC START --- */
        // --- Centralized App State ---
        let appState = {
            user: {
                username: "",
                email: "",
                waterDrankDaily: 0,
                waterDailyGoal: 2,
                waterDrankMonthly: 0,
                waterMonthlyGoal: 60,
                runDistanceDaily: 0,
                runDailyGoal: 5,
                runDistanceMonthly: 0,
                runMonthlyGoal: 100,
                totalRunDistance: 0,
                friends: [],
                isPremium: false,
                lastDailyReset: new Date().toDateString(),
                lastMonthlyReset: new Date(new Date().getFullYear(), new Date().getMonth(), 1).toDateString(),
                // Removed waterRemindersEnabled, runRemindersEnabled, waterReminderIntervalHours, runReminderTime, lastWaterReminderSent, lastRunReminderSent
            },
            currentRun: {
                isActive: false,
                segmentDistance: 0,
                routeCoordinates: [],
                watchId: null,
                map: null,
                marker: null,
                polyline: null
            },
            otherRunners: [
                { name: "Alice", totalRunDistance: 7.2 },
                { name: "Bob", totalRunDistance: 5.5 },
                { name: "Charlie", totalRunDistance: 6.8 },
                { name: "Diana", totalRunDistance: 8.1 },
                { name: "Eve", totalRunDistance: 12.3 },
                { name: "Frank", totalRunDistance: 4.0 }
            ],
            cameraStream: null,
            myLocationMarker: null,
            // NEW: Timer-specific state for RUNNING
            oneTimeRunTimerId: null,
            oneTimeRunTimerEndTime: null, // To store when the run timer is due
            // NEW: Timer-specific state for WATER
            oneTimeWaterTimerId: null,
            oneTimeWaterTimerEndTime: null // To store when the water timer is due
        };

        // --- Define your arrays of tips (for dynamic display) ---
        const waterTips = [
            "Stay consistent: Sip water throughout the day, don't wait until you're thirsty!",
            "Hydrate before meals: Drinking a glass of water before eating can aid digestion and help manage appetite.",
            "Factor in activity: Increase your water intake when exercising or in hot weather. Aim for 0.5-1.0L per hour of moderate to intense activity.",
            "Monitor urine color: Pale yellow usually indicates good hydration. Darker urine suggests you need more water.",
            "Add flavor naturally: If plain water is boring, try adding slices of lemon, cucumber, or berries.",
            "Keep a water bottle handy: Having water within reach makes it easier to remember to drink regularly.",
            "Set reminders: Use alarms or apps to remind yourself to drink water throughout the day.",
            "Drink an extra glass for every alcoholic drink: Alcohol is dehydrating, so compensate accordingly."
        ];

        const runTips = [
            "Pre-run hydration: Drink 500ml of water 1-2 hours before your run.",
            "During long runs: For runs over 60 minutes, consider electrolytes or sports drinks. Aim for 150-250ml every 15-20 minutes.",
            "Post-run recovery: Replenish fluids and electrolytes immediately after your run. Weigh yourself before and after a run to estimate fluid loss (1kg lost = 1 liter to replace).",
            "Warm-up is key: Always start with a dynamic warm-up to prepare your muscles and prevent injury.",
            "Listen to your body: Don't push through sharp pain. Rest and recovery are just as important as training.",
            "Gradual progression: Increase your distance or intensity by no much more than 10% per week to avoid injury.",
            "Vary your routes: Running on different terrains can strengthen various muscle groups and keep things interesting.",
            "Invest in good shoes: Proper running shoes are crucial for comfort and preventing injuries. Replace them every 500-800 km."
        ];


        // --- Utility: Local Storage ---
        function saveAppState() {
            localStorage.setItem('hydrunAppState', JSON.stringify(appState.user));
            // Save timer states separately
            localStorage.setItem('hydrunRunTimerState', JSON.stringify({
                oneTimeRunTimerId: appState.oneTimeRunTimerId !== null ? 'active' : null,
                oneTimeRunTimerEndTime: appState.oneTimeRunTimerEndTime
            }));
            localStorage.setItem('hydrunWaterTimerState', JSON.stringify({
                oneTimeWaterTimerId: appState.oneTimeWaterTimerId !== null ? 'active' : null,
                oneTimeWaterTimerEndTime: appState.oneTimeWaterTimerEndTime
            }));
        }

        function loadAppState() {
            const storedUser = localStorage.getItem('hydrunAppState');
            if (storedUser) {
                const loadedUser = JSON.parse(storedUser);
                appState.user.username = loadedUser.username || "";
                appState.user.email = loadedUser.email || "";
                appState.user.waterDrankDaily = parseFloat(loadedUser.waterDrankDaily) || 0;
                appState.user.waterDailyGoal = parseFloat(loadedUser.waterDailyGoal) || 2;
                appState.user.waterDrankMonthly = parseFloat(loadedUser.waterDrankMonthly) || 0;
                appState.user.waterMonthlyGoal = parseFloat(loadedUser.waterMonthlyGoal) || 60;
                appState.user.runDistanceDaily = parseFloat(loadedUser.runDistanceDaily) || 0;
                appState.user.runDailyGoal = parseFloat(loadedUser.runDailyGoal) || 5;
                appState.user.runDistanceMonthly = parseFloat(loadedUser.runDistanceMonthly) || 0;
                appState.user.runMonthlyGoal = parseFloat(loadedUser.runMonthlyGoal) || 100;
                appState.user.totalRunDistance = parseFloat(loadedUser.totalRunDistance) || 0;
                appState.user.friends = loadedUser.friends || [];
                appState.user.isPremium = loadedUser.isPremium || false;
                appState.user.lastDailyReset = loadedUser.lastDailyReset || new Date().toDateString();
                appState.user.lastMonthlyReset = loadedUser.lastMonthlyReset || new Date(new Date().getFullYear(), new Date().getMonth(), 1).toDateString();
            }

            // Load Run Timer state
            const storedRunTimer = localStorage.getItem('hydrunRunTimerState');
            if (storedRunTimer) {
                const loadedRunTimer = JSON.parse(storedRunTimer);
                appState.oneTimeRunTimerEndTime = loadedRunTimer.oneTimeRunTimerEndTime;
                if (appState.oneTimeRunTimerEndTime && new Date(appState.oneTimeRunTimerEndTime) <= new Date()) {
                    appState.oneTimeRunTimerEndTime = null; // Clear if expired
                    localStorage.removeItem('hydrunRunTimerState');
                }
            }

            // Load Water Timer state
            const storedWaterTimer = localStorage.getItem('hydrunWaterTimerState');
            if (storedWaterTimer) {
                const loadedWaterTimer = JSON.parse(storedWaterTimer);
                appState.oneTimeWaterTimerEndTime = loadedWaterTimer.oneTimeWaterTimerEndTime;
                if (appState.oneTimeWaterTimerEndTime && new Date(appState.oneTimeWaterTimerEndTime) <= new Date()) {
                    appState.oneTimeWaterTimerEndTime = null; // Clear if expired
                    localStorage.removeItem('hydrunWaterTimerState');
                }
            }
            checkAndResetGoals();
        }

        function checkAndResetGoals() {
            const today = new Date().toDateString();
            const thisMonthStart = new Date(new Date().getFullYear(), new Date().getMonth(), 1).toDateString();

            // Daily reset
            if (appState.user.lastDailyReset !== today) {
                console.log("Resetting daily goals...");
                appState.user.waterDrankDaily = 0;
                appState.user.runDistanceDaily = 0;
                appState.user.lastDailyReset = today;
                saveAppState();
            }

            // Monthly reset
            if (appState.user.lastMonthlyReset !== thisMonthStart) {
                console.log("Resetting monthly goals...");
                appState.user.waterDrankMonthly = 0;
                appState.user.runDistanceMonthly = 0;
                appState.user.lastMonthlyReset = thisMonthStart;
                saveAppState();
            }
        }

        // --- UI Feedback Helper ---
        function showFeedback(elementId, message, type = 'success', duration = 3000) {
            const feedbackElement = document.getElementById(elementId);
            feedbackElement.textContent = message;
            feedbackElement.className = `feedback-message show ${type}`;
            feedbackElement.classList.remove('hidden');
            setTimeout(() => {
                feedbackElement.classList.add('hidden');
                feedbackElement.classList.remove('show');
            }, duration);
        }

        // --- Function to get random tips and update the display ---
        function updateTips(sectionId) {
            let tipsArray;
            let targetListId;

            if (sectionId === 'waterSection') {
                tipsArray = waterTips;
                targetListId = 'waterAdviceList';
            } else if (sectionId === 'runSection') {
                tipsArray = runTips;
                targetListId = 'runAdviceList';
            } else {
                return; // Do nothing if unknown section
            }

            const tipList = document.getElementById(targetListId);
            tipList.innerHTML = ''; // Clear previous tips

            // Shuffle the tips array (Fisher-Yates algorithm)
            for (let i = tipsArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tipsArray[i], tipsArray[j]] = [tipsArray[j], tipsArray[i]];
            }

            // Display a few random tips (e.g., 3-5 tips)
            const numTipsToShow = Math.min(Math.floor(Math.random() * 3) + 3, tipsArray.length); // 3 to 5 tips
            for (let i = 0; i < numTipsToShow; i++) {
                const li = document.createElement('li');
                li.textContent = tipsArray[i];
                tipList.appendChild(li);
            }
        }

        // --- Section Toggling ---
        function showSection(sectionIdToShow) {
            const sections = ['waterSection', 'runSection', 'profileSection', 'premiumSection'];
            const buttons = {
                'waterSection': document.getElementById('showWaterBtn'),
                'runSection': document.getElementById('showRunBtn'),
                'profileSection': document.getElementById('showProfileBtn'),
                'premiumSection': document.getElementById('showPremiumBtn')
            };

            sections.forEach(id => {
                const section = document.getElementById(id);
                const button = buttons[id];

                if (id === sectionIdToShow) {
                    section.classList.remove('hidden');
                    if (button) button.classList.add('active');
                    if (id === 'waterSection' || id === 'runSection') {
                         updateTips(id);
                    } else if (id === 'premiumSection') {
                        updatePremiumUI();
                    } else if (id === 'profileSection') {
                        updateProfileUI();
                        updateRunTimerUI(); // Update run timer UI when profile is shown
                        updateWaterTimerUI(); // Update water timer UI when profile is shown
                    }
                } else {
                    section.classList.add('hidden');
                    if (button) button.classList.remove('active');
                }
            });

            // Special handling for the map when run section is shown
            if (sectionIdToShow === 'runSection') {
                initMap();
                if (appState.currentRun.map) {
                    appState.currentRun.map.invalidateSize();
                    if (appState.currentRun.marker) {
                        appState.currentRun.map.setView(appState.currentRun.marker.getLatLng(), appState.currentRun.map.getZoom());
                    } else if (appState.currentRun.routeCoordinates.length > 0) {
                        const bounds = L.latLngBounds(appState.currentRun.routeCoordinates);
                        appState.currentRun.map.fitBounds(bounds);
                    } else if (appState.myLocationMarker) {
                         appState.currentRun.map.setView(appState.myLocationMarker.getLatLng(), appState.currentRun.map.getZoom());
                    } else {
                        navigator.geolocation.getCurrentPosition(pos => {
                            const { latitude, longitude } = pos.coords;
                            appState.currentRun.map.setView([latitude, longitude], 13);
                        }, () => {
                            appState.currentRun.map.setView([38.7223, -9.1393], 13);
                        });
                    }
                }
            }
        }


        // --- Core UI Management ---
        function updateAppUI() {
            if (appState.user.username && appState.user.email) {
                document.getElementById("loginContainer").classList.add("hidden");
                document.getElementById("appContainer").classList.remove("hidden");
                document.getElementById("userDisplay").textContent = appState.user.username;

                document.getElementById("waterDailyGoal").value = appState.user.waterDailyGoal;
                document.getElementById("waterMonthlyGoal").value = appState.user.waterMonthlyGoal;
                document.getElementById("runDailyGoal").value = appState.user.runDailyGoal;
                document.getElementById("runMonthlyGoal").value = appState.user.runMonthlyGoal;

                updateWaterProgress();
                updateRunProgress();
                updateTotalRunDisplay();
                updateFriendList();
                updateLeaderboard();
                updatePremiumUI();
                updateProfileUI(); // Calls individual timer UIs

                showSection('waterSection');
            } else {
                document.getElementById("loginContainer").classList.remove("hidden");
                document.getElementById("appContainer").classList.add("hidden");
            }
        }

        // --- Login/Logout ---
        function login() {
            const userEmailInput = document.getElementById("userEmail");
            const usernameInput = document.getElementById("usernameInput");

            const email = userEmailInput.value.trim();
            const username = usernameInput.value.trim();

            if (!email || !username) {
                alert("Please enter both an email and a username to log in.");
                return;
            }

            appState.user.username = username;
            appState.user.email = email;
            saveAppState();
            updateAppUI();
        }

        function logout() {
            cancelOneTimeRunTimerReminder(); // Cancel any active run timer on logout
            cancelOneTimeWaterTimerReminder(); // Cancel any active water timer on logout

            localStorage.removeItem('hydrunAppState');
            localStorage.removeItem('hydrunRunTimerState'); // Clear run timer state
            localStorage.removeItem('hydrunWaterTimerState'); // Clear water timer state
            location.reload();
        }

        // --- Water Tracking ---
        function logWater() {
            const waterInput = document.getElementById("waterInput");
            const amount = parseFloat(waterInput.value);
            if (!isNaN(amount) && amount > 0) {
                appState.user.waterDrankDaily += amount;
                appState.user.waterDrankMonthly += amount;
                waterInput.value = '';
                saveAppState();
                updateWaterProgress();
                showFeedback('waterFeedback', `${amount.toFixed(2)} L of water added!`);
            } else {
                alert("Please enter a valid positive number for water.");
            }
        }

        function updateWaterProgress() {
            const dailyGoalInput = document.getElementById("waterDailyGoal");
            const monthlyGoalInput = document.getElementById("waterMonthlyGoal");

            const dailyGoal = parseFloat(dailyGoalInput.value);
            const monthlyGoal = parseFloat(monthlyGoalInput.value);

            let feedbackMessage = "";

            if (!isNaN(dailyGoal) && dailyGoal > 0) {
                if (appState.user.waterDailyGoal !== dailyGoal) {
                    appState.user.waterDailyGoal = dailyGoal;
                    feedbackMessage += `Daily water goal updated to ${dailyGoal.toFixed(1)} L. `;
                }
            } else {
                dailyGoalInput.value = appState.user.waterDailyGoal;
            }

            if (!isNaN(monthlyGoal) && monthlyGoal > 0) {
                if (appState.user.waterMonthlyGoal !== monthlyGoal) {
                    appState.user.waterMonthlyGoal = monthlyGoal;
                    feedbackMessage += `Monthly water goal updated to ${monthlyGoal.toFixed(1)} L.`;
                }
            } else {
                monthlyGoalInput.value = appState.user.waterMonthlyGoal;
            }

            if (feedbackMessage) {
                showFeedback('waterFeedback', feedbackMessage);
            }

            const dailyPercent = ((appState.user.waterDrankDaily / appState.user.waterDailyGoal) * 100).toFixed(1);
            document.getElementById("waterDailyStatus").textContent =
                `Drank: ${appState.user.waterDrankDaily.toFixed(2)} L (${dailyPercent}%)`;

            const monthlyPercent = ((appState.user.waterDrankMonthly / appState.user.waterMonthlyGoal) * 100).toFixed(1);
            document.getElementById("waterMonthlyStatus").textContent =
                `Drank: ${appState.user.waterDrankMonthly.toFixed(2)} L (${monthlyPercent}%)`;

            saveAppState();
        }

        document.getElementById("waterDailyGoal").addEventListener('change', updateWaterProgress);
        document.getElementById("waterMonthlyGoal").addEventListener('change', updateWaterProgress);

        // --- Camera Functionality ---
        const cameraStreamElement = document.getElementById('cameraStream');
        const captureCanvas = document.getElementById('captureCanvas');
        const canvasContext = captureCanvas.getContext('2d');
        const waterInputManual = document.getElementById('waterInput');

        async function startCamera() {
            if (appState.cameraStream) {
                showFeedback('cameraFeedback', 'Camera already active.', 'info');
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                appState.cameraStream = stream;
                cameraStreamElement.srcObject = stream;
                cameraStreamElement.classList.remove('hidden');
                captureCanvas.classList.add('hidden');
                showFeedback('cameraFeedback', 'Camera started! Point it at your container, then "Capture Image".');
            } catch (err) {
                console.error('Error accessing camera:', err);
                let errorMessage = 'Could not access camera.';
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    errorMessage = 'Camera access denied. Please allow camera permissions.';
                } else if (err.name === 'NotFoundError') {
                    errorMessage = 'No camera found on this device.';
                }
                showFeedback('cameraFeedback', errorMessage, 'error');
            }
        }

        function captureImage() {
            if (!appState.cameraStream) {
                showFeedback('cameraFeedback', 'Camera not active. Please start camera first.', 'error');
                return;
            }

            captureCanvas.width = cameraStreamElement.videoWidth;
            captureCanvas.height = cameraStreamElement.videoHeight;

            canvasContext.drawImage(cameraStreamElement, 0, 0, captureCanvas.width, captureCanvas.height);

            captureCanvas.classList.remove('hidden');
            cameraStreamElement.classList.add('hidden');

            showFeedback('cameraFeedback', 'Image captured! Now, based on the picture, manually estimate the water amount and use the "Add Water" button above.', 'info', 7000);
            waterInputManual.focus();
        }

        function stopCamera() {
            if (appState.cameraStream) {
                appState.cameraStream.getTracks().forEach(track => track.stop());
                appState.cameraStream = null;
                cameraStreamElement.srcObject = null;
                cameraStreamElement.classList.add('hidden');
                captureCanvas.classList.add('hidden');
                showFeedback('cameraFeedback', 'Camera stopped.', 'info');
            } else {
                showFeedback('cameraFeedback', 'Camera is not active.', 'info');
            }
        }

        // --- Run Tracking (Leaflet Integration) ---
        function initMap() {
            if (appState.currentRun.map) {
                return;
            }

            appState.currentRun.map = L.map('map');

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(appState.currentRun.map);

            navigator.geolocation.getCurrentPosition(pos => {
                const { latitude, longitude } = pos.coords;
                const initialCoords = [latitude, longitude];
                appState.currentRun.map.setView(initialCoords, 16);

                if (!appState.currentRun.isActive && !appState.myLocationMarker) {
                    appState.myLocationMarker = L.marker(initialCoords, {
                        icon: L.ExtraMarkers.icon({
                            icon: 'fa-map-pin',
                            markerColor: 'blue',
                            prefix: 'fa'
                        })
                    }).addTo(appState.currentRun.map)
                      .bindPopup('Your current location on load!').openPopup();
                }
            }, () => {
                appState.currentRun.map.setView([38.7223, -9.1393], 13);
                showFeedback('runFeedback', 'Could not get your location for map initialization. Displaying Lisbon.', 'error', 5000);
            });
        }

        function markMyLocation() {
            if (!appState.currentRun.map) {
                showFeedback('runFeedback', 'Map not initialized. Please ensure Run Tracker is active.', 'error');
                return;
            }

            showFeedback('runFeedback', 'Requesting your current location...', 'info');

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const { latitude, longitude } = position.coords;
                    const currentLocation = [latitude, longitude];

                    if (appState.myLocationMarker) {
                        appState.myLocationMarker.setLatLng(currentLocation);
                    } else {
                        appState.myLocationMarker = L.marker(currentLocation, {
                            icon: L.ExtraMarkers.icon({
                                icon: 'fa-map-pin',
                                markerColor: 'blue',
                                prefix: 'fa'
                            })
                        }).addTo(appState.currentRun.map);
                    }

                    appState.currentRun.map.setView(currentLocation, appState.currentRun.map.getZoom() || 16);
                    appState.myLocationMarker.bindPopup('Your marked location!').openPopup();
                    showFeedback('runFeedback', `Location marked at Latitude: ${latitude.toFixed(4)}, Longitude: ${longitude.toFixed(4)}`, 'success');
                    console.log('Manually marked location:', currentLocation);
                },
                (error) => {
                    let errorMessage = 'Could not mark location: ';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage += "Permission denied. Please allow location access in your browser settings.";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage += "Location information is unavailable.";
                            break;
                        case error.TIMEOUT:
                            errorMessage += "The request to get your location timed out.";
                            break;
                        case error.UNKNOWN_ERROR:
                            errorMessage += "An unknown error occurred.";
                            break;
                    }
                    showFeedback('runFeedback', errorMessage, 'error', 7000);
                    console.error('Geolocation Error for Mark My Location:', error);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }

        function startRun() {
            if (appState.currentRun.isActive) {
                showFeedback('runFeedback', 'Already running!', 'info');
                return;
            }

            if (!appState.currentRun.map) {
                showFeedback('runFeedback', 'Map not initialized. Please ensure Run Tracker is active.', 'error');
                return;
            }

            appState.currentRun.isActive = true;
            appState.currentRun.segmentDistance = 0;
            appState.currentRun.routeCoordinates = [];
            showFeedback('runFeedback', 'Starting run...', 'info');
            document.getElementById('runStatus').textContent = 'Running...';
            document.getElementById('distanceDisplay').textContent = 'Current Run: 0.00 km';

            if (appState.currentRun.polyline) {
                appState.currentRun.map.removeLayer(appState.currentRun.polyline);
                appState.currentRun.polyline = null;
            }
            if (appState.currentRun.marker) {
                appState.currentRun.map.removeLayer(appState.currentRun.marker);
                appState.currentRun.marker = null;
            }
            if (appState.myLocationMarker) {
                appState.currentRun.map.removeLayer(appState.myLocationMarker);
                appState.myLocationMarker = null;
            }


            appState.currentRun.watchId = navigator.geolocation.watchPosition(
                (position) => {
                    const { latitude, longitude } = position.coords;
                    const newPoint = [latitude, longitude];

                    if (!appState.currentRun.marker) {
                        appState.currentRun.marker = L.marker(newPoint, {
                            icon: L.ExtraMarkers.icon({
                                icon: 'fa-person-running',
                                markerColor: 'red',
                                prefix: 'fa'
                            })
                        }).addTo(appState.currentRun.map);
                        appState.currentRun.map.setView(newPoint, 16);
                    } else {
                        appState.currentRun.marker.setLatLng(newPoint);
                    }

                    appState.currentRun.routeCoordinates.push(newPoint);

                    if (appState.currentRun.polyline) {
                        appState.currentRun.polyline.setLatLngs(appState.currentRun.routeCoordinates);
                    } else {
                        appState.currentRun.polyline = L.polyline(appState.currentRun.routeCoordinates, { color: 'blue', weight: 5 }).addTo(appState.currentRun.map);
                    }

                    appState.currentRun.map.panTo(newPoint);

                    if (appState.currentRun.routeCoordinates.length > 1) {
                        const prevPoint = appState.currentRun.routeCoordinates[appState.currentRun.routeCoordinates.length - 2];
                        const distance = calculateDistance(prevPoint[0], prevPoint[1], newPoint[0], newPoint[1]);
                        appState.currentRun.segmentDistance += distance;
                        document.getElementById('distanceDisplay').textContent = `Current Run: ${appState.currentRun.segmentDistance.toFixed(2)} km`;
                    }

                    console.log('Tracking:', newPoint);
                },
                (error) => {
                    let errorMessage = 'Error tracking run: ';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage += "Location permission denied. Cannot track run.";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage += "Location information unavailable.";
                            break;
                        case error.TIMEOUT:
                            errorMessage += "Location tracking timed out.";
                            break;
                        default:
                            errorMessage += "An unknown error occurred.";
                    }
                    showFeedback('runFeedback', errorMessage, 'error', 7000);
                    console.error('Run Tracking Geolocation Error:', error);
                    stopRun();
                },
                {
                    enableHighAccuracy: true,
                    timeout: 15000,
                    maximumAge: 0
                }
            );
        }

        function stopRun() {
            if (!appState.currentRun.isActive) {
                showFeedback('runFeedback', 'Not currently running.', 'info');
                return;
            }

            navigator.geolocation.clearWatch(appState.currentRun.watchId);
            appState.currentRun.isActive = false;

            appState.user.runDistanceDaily += appState.currentRun.segmentDistance;
            appState.user.runDistanceMonthly += appState.currentRun.segmentDistance;
            appState.user.totalRunDistance += appState.currentRun.segmentDistance;

            document.getElementById('runStatus').textContent = 'Not running';
            document.getElementById('distanceDisplay').textContent = `Current Run: 0.00 km`;

            saveAppState();
            updateRunProgress();
            updateTotalRunDisplay();
            updateLeaderboard();
            showFeedback('runFeedback', `Run stopped! Distance: ${appState.currentRun.segmentDistance.toFixed(2)} km`, 'success');
            console.log('Run stopped. Total distance this run:', appState.currentRun.segmentDistance.toFixed(2), 'km');

            appState.currentRun.segmentDistance = 0;
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * (Math.PI / 180);
            const dLon = (lon2 - lon1) * (Math.PI / 180);
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c;
            return distance;
        }

        function updateRunProgress() {
            const dailyGoalInput = document.getElementById("runDailyGoal");
            const monthlyGoalInput = document.getElementById("runMonthlyGoal");

            const dailyGoal = parseFloat(dailyGoalInput.value);
            const monthlyGoal = parseFloat(monthlyGoalInput.value);

            let feedbackMessage = "";

            if (!isNaN(dailyGoal) && dailyGoal > 0) {
                if (appState.user.runDailyGoal !== dailyGoal) {
                    appState.user.runDailyGoal = dailyGoal;
                    feedbackMessage += `Daily run goal updated to ${dailyGoal.toFixed(1)} km. `;
                }
            } else {
                dailyGoalInput.value = appState.user.runDailyGoal;
            }

            if (!isNaN(monthlyGoal) && monthlyGoal > 0) {
                if (appState.user.runMonthlyGoal !== monthlyGoal) {
                    appState.user.runMonthlyGoal = monthlyGoal;
                    feedbackMessage += `Monthly run goal updated to ${monthlyGoal.toFixed(1)} km.`;
                }
            } else {
                monthlyGoalInput.value = appState.user.runMonthlyGoal;
            }

            if (feedbackMessage) {
                showFeedback('runFeedback', feedbackMessage);
            }

            const dailyPercent = ((appState.user.runDistanceDaily / appState.user.runDailyGoal) * 100).toFixed(1);
            document.getElementById("runDailyStatus").textContent =
                `Ran: ${appState.user.runDistanceDaily.toFixed(2)} km (${dailyPercent}%)`;

            const monthlyPercent = ((appState.user.runDistanceMonthly / appState.user.runMonthlyGoal) * 100).toFixed(1);
            document.getElementById("runMonthlyStatus").textContent =
                `Ran: ${appState.user.runDistanceMonthly.toFixed(2)} km (${monthlyPercent}%)`;

            saveAppState();
        }

        document.getElementById("runDailyGoal").addEventListener('change', updateRunProgress);
        document.getElementById("runMonthlyGoal").addEventListener('change', updateRunProgress);

        function updateTotalRunDisplay() {
            document.getElementById("totalRunDisplay").textContent = `${appState.user.totalRunDistance.toFixed(2)} km`;
        }

        // --- Friends & Leaderboard ---
        function addFriend() {
            const friendNameInput = document.getElementById("friendName");
            const friendName = friendNameInput.value.trim();
            if (!friendName) {
                showFeedback('friendFeedback', "Please enter a friend's username.", 'error');
                return;
            }
            if (friendName === appState.user.username) {
                showFeedback('friendFeedback', "You can't add yourself as a friend!", 'error');
                return;
            }
            if (appState.user.friends.includes(friendName)) {
                showFeedback('friendFeedback', `${friendName} is already your friend.`, 'info');
                return;
            }
            appState.user.friends.push(friendName);
            friendNameInput.value = '';
            saveAppState();
            updateFriendList();
            showFeedback('friendFeedback', `${friendName} added to your friends!`, 'success');
        }

        function updateFriendList() {
            const friendListElement = document.getElementById("friendList");
            friendListElement.innerHTML = '';
            if (appState.user.friends.length === 0) {
                friendListElement.innerHTML = '<li>No friends added yet.</li>';
                return;
            }
            appState.user.friends.forEach(friend => {
                const li = document.createElement('li');
                li.textContent = friend;
                friendListElement.appendChild(li);
            });
        }

        function updateLeaderboard() {
            const leaderboardListElement = document.getElementById("leaderboardList");
            leaderboardListElement.innerHTML = '';

            const allRunners = appState.otherRunners.map(runner => ({
                name: runner.name,
                distance: parseFloat(runner.totalRunDistance)
            }));
            allRunners.push({
                name: appState.user.username,
                distance: parseFloat(appState.user.totalRunDistance)
            });

            allRunners.sort((a, b) => b.distance - a.distance);

            allRunners.forEach(runner => {
                const li = document.createElement('li');
                li.textContent = `${runner.name}: ${runner.distance.toFixed(2)} km`;
                if (runner.name === appState.user.username) {
                    li.classList.add('highlight-user');
                }
                leaderboardListElement.appendChild(li);
            });
        }

        // --- Premium Pass Logic ---
        function activatePremium() {
            appState.user.isPremium = true;
            saveAppState();
            updatePremiumUI();
            showFeedback('premiumFeedback', 'Premium Pass activated! Enjoy your exclusive content!', 'success', 5000);
        }

        function updatePremiumUI() {
            const premiumContentDiv = document.getElementById('premiumContent');
            const premiumFeaturesDiv = document.getElementById('premiumFeatures');
            const premiumFeedbackDiv = document.getElementById('premiumFeedback');

            if (appState.user.isPremium) {
                premiumContentDiv.classList.add('hidden');
                premiumFeaturesDiv.classList.remove('hidden');
                premiumFeedbackDiv.classList.add('hidden');
            } else {
                premiumContentDiv.classList.remove('hidden');
                premiumFeaturesDiv.classList.add('hidden');
            }
        }

        // --- Profile Section Logic ---
        function updateProfileUI() {
            document.getElementById('profileUsernameDisplay').textContent = appState.user.username;
            document.getElementById('profileEmailDisplay').textContent = appState.user.email;

            // Call individual timer UI updates
            updateRunTimerUI();
            updateWaterTimerUI();
        }

        // --- Notification Permission Helper ---
        async function requestNotificationPermission(callback) {
            if (!("Notification" in window)) {
                showFeedback('runTimerFeedback', "This browser does not support desktop notifications.", 'error'); // Using run timer feedback for general
                if (callback) callback(false);
                return false;
            }

            if (Notification.permission === "granted") {
                if (callback) callback(true);
                return true;
            }

            if (Notification.permission !== "denied") {
                const permission = await Notification.requestPermission();
                if (permission === "granted") {
                    showFeedback('runTimerFeedback', "Notification permission granted!", 'success');
                    if (callback) callback(true);
                    return true;
                } else {
                    showFeedback('runTimerFeedback', "Notification permission denied. Timers cannot send notifications.", 'error');
                    if (callback) callback(false);
                    return false;
                }
            } else {
                showFeedback('runTimerFeedback', "Notification permission was denied. Please enable it in your browser settings.", 'error', 7000);
                if (callback) callback(false);
                return false;
            }
        }

        // --- NEW: One-Time Run Timer Functions ---
        let runTimerCountdownInterval = null; // To hold the setInterval ID for the visual countdown

        function setOneTimeRunTimerReminder() {
            const hours = parseInt(document.getElementById('runTimerHours').value) || 0;
            const minutes = parseInt(document.getElementById('runTimerMinutes').value) || 0;
            const seconds = parseInt(document.getElementById('runTimerSeconds').value) || 0;
            const message = document.getElementById('runTimerMessage').value.trim();

            const totalMilliseconds = (hours * 3600 + minutes * 60 + seconds) * 1000;

            if (totalMilliseconds <= 0) {
                showFeedback('runTimerFeedback', 'Please enter a valid time (hours, minutes, or seconds).', 'error');
                return;
            }
            if (!message) {
                showFeedback('runTimerFeedback', 'Please enter a reminder message.', 'error');
                return;
            }
            if (appState.oneTimeRunTimerId) {
                showFeedback('runTimerFeedback', 'A run timer is already active. Cancel it first to set a new one.', 'info');
                return;
            }

            requestNotificationPermission(async (granted) => {
                if (granted) {
                    showFeedback('runTimerFeedback', 'Run timer set! You will be notified shortly.', 'success');

                    appState.oneTimeRunTimerId = setTimeout(() => {
                        new Notification("üèÉ Hydrun: Time to Run!", {
                            body: message,
                            icon: 'https://via.placeholder.com/64/ff9800/ffffff?text=üèÉ', // Orange runner icon
                            renotify: true,
                            tag: 'one-time-run-timer-reminder'
                        });
                        appState.oneTimeRunTimerId = null; // Clear timer ID after it fires
                        appState.oneTimeRunTimerEndTime = null;
                        localStorage.removeItem('hydrunRunTimerState'); // Clear from local storage
                        updateRunTimerUI(); // Update UI
                        showFeedback('runTimerFeedback', 'Run timer finished!', 'success', 5000);
                    }, totalMilliseconds);

                    appState.oneTimeRunTimerEndTime = new Date(new Date().getTime() + totalMilliseconds).toISOString();
                    saveAppState(); // Save the end time

                    // Start visual countdown
                    setRunVisualTimer(totalMilliseconds);

                } else {
                    showFeedback('runTimerFeedback', 'Notification permission required to set timer.', 'error');
                }
            });
        }

        function cancelOneTimeRunTimerReminder() {
            if (appState.oneTimeRunTimerId) {
                clearTimeout(appState.oneTimeRunTimerId);
                appState.oneTimeRunTimerId = null;
                appState.oneTimeRunTimerEndTime = null;
                localStorage.removeItem('hydrunRunTimerState'); // Clear from local storage
                showFeedback('runTimerFeedback', 'Run timer cancelled.', 'info');
            } else {
                showFeedback('runTimerFeedback', 'No active run timer to cancel.', 'info');
            }
            updateRunTimerUI(); // Update UI regardless
            if (runTimerCountdownInterval) {
                clearInterval(runTimerCountdownInterval);
                runTimerCountdownInterval = null;
            }
        }

        function updateRunTimerUI() {
            const timerStatusElement = document.getElementById('runTimerStatus');
            const timerHoursInput = document.getElementById('runTimerHours');
            const timerMinutesInput = document.getElementById('runTimerMinutes');
            const timerSecondsInput = document.getElementById('runTimerSeconds');
            const timerMessageInput = document.getElementById('runTimerMessage');

            // Set default message if empty
            if (!timerMessageInput.value) {
                timerMessageInput.value = "Time to run!";
            }

            // Reset inputs unless a timer is active (but we don't restore input values, just status)
            if (!appState.oneTimeRunTimerId && (!appState.oneTimeRunTimerEndTime || new Date(appState.oneTimeRunTimerEndTime) < new Date())) {
                timerStatusElement.textContent = 'No run timer active.';
                timerHoursInput.value = 0;
                timerMinutesInput.value = 0;
                timerSecondsInput.value = 0;
            }
            // If timer was set and page reloaded, the setTimeout is lost, but endTime remains.
            else if (appState.oneTimeRunTimerEndTime && new Date(appState.oneTimeRunTimerEndTime) > new Date()) {
                const remaining = new Date(appState.oneTimeRunTimerEndTime).getTime() - new Date().getTime();
                if (remaining > 0) {
                     // Ensure visual countdown is running if the timer is logically active (due to stored endTime)
                    if (!runTimerCountdownInterval) {
                        setRunVisualTimer(remaining);
                    }
                } else {
                    timerStatusElement.textContent = 'No run timer active.'; // Should have been cleared by setTimeout, but just in case
                    appState.oneTimeRunTimerEndTime = null;
                    localStorage.removeItem('hydrunRunTimerState');
                }
            }
        }

        // Handles the visual countdown on the UI for RUN timer
        function setRunVisualTimer(initialMilliseconds) {
            const timerStatusElement = document.getElementById('runTimerStatus');
            const endTime = new Date().getTime() + initialMilliseconds;

            if (runTimerCountdownInterval) {
                clearInterval(runTimerCountdownInterval); // Clear any existing visual interval
            }

            runTimerCountdownInterval = setInterval(() => {
                const now = new Date().getTime();
                const distance = endTime - now;

                if (distance < 0) {
                    clearInterval(runTimerCountdownInterval);
                    runTimerCountdownInterval = null;
                    timerStatusElement.textContent = 'Run timer finished!';
                    // The actual notification setTimeout handles appState.oneTimeRunTimerId = null;
                    return;
                }

                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);

                timerStatusElement.textContent = `Run timer active: ${hours.toString().padStart(2, '0')}h ${minutes.toString().padStart(2, '0')}m ${seconds.toString().padStart(2, '0')}s remaining`;
            }, 1000);
        }


        // --- NEW: One-Time Water Timer Functions ---
        let waterTimerCountdownInterval = null; // To hold the setInterval ID for the visual countdown

        function setOneTimeWaterTimerReminder() {
            const hours = parseInt(document.getElementById('waterTimerHours').value) || 0;
            const minutes = parseInt(document.getElementById('waterTimerMinutes').value) || 0;
            const seconds = parseInt(document.getElementById('waterTimerSeconds').value) || 0;
            const message = document.getElementById('waterTimerMessage').value.trim();

            const totalMilliseconds = (hours * 3600 + minutes * 60 + seconds) * 1000;

            if (totalMilliseconds <= 0) {
                showFeedback('waterTimerFeedback', 'Please enter a valid time (hours, minutes, or seconds).', 'error');
                return;
            }
            if (!message) {
                showFeedback('waterTimerFeedback', 'Please enter a reminder message.', 'error');
                return;
            }
            if (appState.oneTimeWaterTimerId) {
                showFeedback('waterTimerFeedback', 'A water timer is already active. Cancel it first to set a new one.', 'info');
                return;
            }

            requestNotificationPermission(async (granted) => {
                if (granted) {
                    showFeedback('waterTimerFeedback', 'Water timer set! You will be notified shortly.', 'success');

                    appState.oneTimeWaterTimerId = setTimeout(() => {
                        new Notification("üíß Hydrun: Time to Hydrate!", {
                            body: message,
                            icon: 'https://via.placeholder.com/64/0077ff/ffffff?text=üíß', // Blue water drop icon
                            renotify: true,
                            tag: 'one-time-water-timer-reminder'
                        });
                        appState.oneTimeWaterTimerId = null; // Clear timer ID after it fires
                        appState.oneTimeWaterTimerEndTime = null;
                        localStorage.removeItem('hydrunWaterTimerState'); // Clear from local storage
                        updateWaterTimerUI(); // Update UI
                        showFeedback('waterTimerFeedback', 'Water timer finished!', 'success', 5000);
                    }, totalMilliseconds);

                    appState.oneTimeWaterTimerEndTime = new Date(new Date().getTime() + totalMilliseconds).toISOString();
                    saveAppState(); // Save the end time

                    // Start visual countdown
                    setWaterVisualTimer(totalMilliseconds);

                } else {
                    showFeedback('waterTimerFeedback', 'Notification permission required to set timer.', 'error');
                }
            });
        }

        function cancelOneTimeWaterTimerReminder() {
            if (appState.oneTimeWaterTimerId) {
                clearTimeout(appState.oneTimeWaterTimerId);
                appState.oneTimeWaterTimerId = null;
                appState.oneTimeWaterTimerEndTime = null;
                localStorage.removeItem('hydrunWaterTimerState'); // Clear from local storage
                showFeedback('waterTimerFeedback', 'Water timer cancelled.', 'info');
            } else {
                showFeedback('waterTimerFeedback', 'No active water timer to cancel.', 'info');
            }
            updateWaterTimerUI(); // Update UI regardless
            if (waterTimerCountdownInterval) {
                clearInterval(waterTimerCountdownInterval);
                waterTimerCountdownInterval = null;
            }
        }

        function updateWaterTimerUI() {
            const timerStatusElement = document.getElementById('waterTimerStatus');
            const timerHoursInput = document.getElementById('waterTimerHours');
            const timerMinutesInput = document.getElementById('waterTimerMinutes');
            const timerSecondsInput = document.getElementById('waterTimerSeconds');
            const timerMessageInput = document.getElementById('waterTimerMessage');

            // Set default message if empty
            if (!timerMessageInput.value) {
                timerMessageInput.value = "Don't forget to drink water!";
            }

            // Reset inputs unless a timer is active (but we don't restore input values, just status)
            if (!appState.oneTimeWaterTimerId && (!appState.oneTimeWaterTimerEndTime || new Date(appState.oneTimeWaterTimerEndTime) < new Date())) {
                timerStatusElement.textContent = 'No water timer active.';
                timerHoursInput.value = 0;
                timerMinutesInput.value = 0;
                timerSecondsInput.value = 0;
            }
            // If timer was set and page reloaded, the setTimeout is lost, but endTime remains.
            else if (appState.oneTimeWaterTimerEndTime && new Date(appState.oneTimeWaterTimerEndTime) > new Date()) {
                const remaining = new Date(appState.oneTimeWaterTimerEndTime).getTime() - new Date().getTime();
                if (remaining > 0) {
                     // Ensure visual countdown is running if the timer is logically active (due to stored endTime)
                    if (!waterTimerCountdownInterval) {
                        setWaterVisualTimer(remaining);
                    }
                } else {
                    timerStatusElement.textContent = 'No water timer active.'; // Should have been cleared by setTimeout, but just in case
                    appState.oneTimeWaterTimerEndTime = null;
                    localStorage.removeItem('hydrunWaterTimerState');
                }
            }
        }

        // Handles the visual countdown on the UI for WATER timer
        function setWaterVisualTimer(initialMilliseconds) {
            const timerStatusElement = document.getElementById('waterTimerStatus');
            const endTime = new Date().getTime() + initialMilliseconds;

            if (waterTimerCountdownInterval) {
                clearInterval(waterTimerCountdownInterval); // Clear any existing visual interval
            }

            waterTimerCountdownInterval = setInterval(() => {
                const now = new Date().getTime();
                const distance = endTime - now;

                if (distance < 0) {
                    clearInterval(waterTimerCountdownInterval);
                    waterTimerCountdownInterval = null;
                    timerStatusElement.textContent = 'Water timer finished!';
                    // The actual notification setTimeout handles appState.oneTimeWaterTimerId = null;
                    return;
                }

                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);

                timerStatusElement.textContent = `Water timer active: ${hours.toString().padStart(2, '0')}h ${minutes.toString().padStart(2, '0')}m ${seconds.toString().padStart(2, '0')}s remaining`;
            }, 1000);
        }


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            loadAppState();
            updateAppUI();

            // If there's an end time from previous session, and it's in the future, start visual timers
            if (appState.oneTimeRunTimerEndTime && new Date(appState.oneTimeRunTimerEndTime) > new Date()) {
                setRunVisualTimer(new Date(appState.oneTimeRunTimerEndTime).getTime() - new Date().getTime());
            }
            if (appState.oneTimeWaterTimerEndTime && new Date(appState.oneTimeWaterTimerEndTime) > new Date()) {
                setWaterVisualTimer(new Date(appState.oneTimeWaterTimerEndTime).getTime() - new Date().getTime());
            }
        });

        /* --- JAVASCRIPT LOGIC END --- */
    </script>

</body>
</html>
